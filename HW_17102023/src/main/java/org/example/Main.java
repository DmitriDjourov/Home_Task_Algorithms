package org.example;


public class Main {
/*   1 уровень сложности: 1. Вычислить n-й член последовательности, заданной формулами:
  a(2n) = a(n) + a(n-1),
  a(2n+1) = a(n) — a(n-1),
  a(0) = a(1) = 1.

  Т.е.:
  a(2) = a(21) = a(1) + a(0) = 2
  a(3) = a(21 + 1) = a(1) - a(0) = 0
  a(4) = a(22) = a(2) + a(1) = 3
  a(5) = a(22 + 1) = a(2) - a(1) = 1
  a(6) = a(23) = a(3) + a(2) = 2
  a(7) = a(23 + 1) = a(3) - a(2) = -2

  последовательность: 1 1 2 0 3 1 2 -2

 Ответ:
Для вычисления a(n) нужно определить, является ли n четным или нечетным числом, и затем использовать соответствующую
 формулу:
1. Если n - четное, то a(n) = a(n/2) + a(n/2 - 1).
2. Если n - нечетное, то a(n) = a(n/2) - a(n/2 - 1).

Примеры:
1. Для n = 8 (четное число), мы используем первую формулу:
   a(8) = a(8/2) + a(8/2 - 1) = a(4) + a(3) = 3 + 1 = 4.
2. Для n = 9 (нечетное число), мы используем вторую формулу:
   a(9) = a(9/2) - a(9/2 - 1) = a(4) - a(3) = 3 - 1 = 2.

Таким образом, для данной последовательности можно вычислить любой член, используя указанные формулы в зависимости
от четности или нечетности n.
  */
  public static void main(String[] args) {
    int n = 7; // Любое наше значение
    int result = SequenceCalculator.calculateNthTerm(n);
    System.out.println("a(" + n + ") = " + result);

/*    2.
    Самый дешёвый путь
    В каждой клетке прямоугольной таблицы N*M записано некоторое число.
    Изначально игрок находится в левой верхней клетке.
            За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено).
            При проходе через клетку игрок платит определенную сумму, значение которой записано в этой клетке.
            Требуется найти минимальную стоимость пути, отдав которую игрок может попасть в правый нижний угол.

    Например, входные данные алгоритма:
    int[][] pathCost = new int[][] {
            {0,  11,  0,  0,  0, 0},
            {10, 10, 10, 10, 10, 0},
            {10, 10, 10,  4, 10, 0},
    };
    Результат: minimalCost = 11
    int[][] pathCost = new int[][] {
            {0,  11,  0,  0,  0, 100},
            {10, 10, 10, 10, 10,   0},
            {10, 10, 10,  4, 10,   0},
    };
    Результат: minimalCost = 21  */
    int[][] pathCost1 = new int[][] {
            {0, 11, 0, 0, 0, 0},
            {10, 10, 10, 10, 10, 0},
            {10, 10, 10, 4, 10, 0},
    };
    System.out.println("minimalCost = " + MinimalPathCost.findMinimalCost(pathCost1)); // Выводит 11

    int[][] pathCost2 = new int[][] {
            {0, 11, 0, 0, 0, 100},
            {10, 10, 10, 10, 10, 0},
            {10, 10, 10, 4, 10, 0},
    };
    System.out.println("minimalCost = " + MinimalPathCost.findMinimalCost(pathCost2)); // Выводит 21
  }
}